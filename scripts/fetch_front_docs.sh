#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
TMP_DIR="${ROOT_DIR}/.tmp"
FRONT_REPO_DIR="${TMP_DIR}/repo-front"
FRONT_TYPEDOC_OUT="${FRONT_TYPEDOC_OUT:-${TMP_DIR}/typedoc-front}"

FRONT_REPO="${FRONT_REPO:-ORG/repo-front}"
FRONT_REF="${FRONT_REF:-main}"
FRONT_REPO_URL="${FRONT_REPO_URL:-https://github.com/${FRONT_REPO}.git}"
FRONT_REPO_TOKEN="${FRONT_REPO_TOKEN:-${GH_PAT:-}}"

DOCS_OUT_DIR="${ROOT_DIR}/docs/api/front"

mkdir -p "${TMP_DIR}"
rm -rf "${FRONT_REPO_DIR}" "${FRONT_TYPEDOC_OUT}"

if [[ -n "${FRONT_REPO_TOKEN}" ]]; then
  FRONT_REPO_URL="https://x-access-token:${FRONT_REPO_TOKEN}@github.com/${FRONT_REPO}.git"
fi

echo "Cloning front repo: ${FRONT_REPO} (${FRONT_REF})"
git clone --depth 1 --branch "${FRONT_REF}" "${FRONT_REPO_URL}" "${FRONT_REPO_DIR}"

if [[ ! -f "${FRONT_REPO_DIR}/package.json" ]]; then
  echo "ERROR: package.json not found in front repo."
  exit 1
fi

echo "Installing front dependencies"
if [[ -f "${FRONT_REPO_DIR}/package-lock.json" ]]; then
  (cd "${FRONT_REPO_DIR}" && npm ci)
else
  (cd "${FRONT_REPO_DIR}" && npm install)
fi

echo "Generating TypeDoc markdown"
if [[ -n "${FRONT_TYPEDOC_CMD:-}" ]]; then
  (cd "${FRONT_REPO_DIR}" && FRONT_TYPEDOC_OUT="${FRONT_TYPEDOC_OUT}" bash -lc "${FRONT_TYPEDOC_CMD}")
else
  (cd "${FRONT_REPO_DIR}" && npx typedoc --plugin typedoc-plugin-markdown --out "${FRONT_TYPEDOC_OUT}")
fi

if [[ ! -d "${FRONT_TYPEDOC_OUT}" ]]; then
  echo "ERROR: TypeDoc output directory not found: ${FRONT_TYPEDOC_OUT}"
  exit 1
fi

if ! find "${FRONT_TYPEDOC_OUT}" -type f \( -name "*.md" -o -name "*.mdx" \) | grep -q .; then
  echo "ERROR: No markdown files generated by TypeDoc."
  exit 1
fi

rm -rf "${DOCS_OUT_DIR}"
mkdir -p "${DOCS_OUT_DIR}"
cp -R "${FRONT_TYPEDOC_OUT}/." "${DOCS_OUT_DIR}/"

echo "Front API docs copied to ${DOCS_OUT_DIR}"

# ---------------------------------------------------------------------
# MDX sanitize:
# Docusaurus (MDX) evalÃºa `{id}` como JS y rompe el build con:
# "ReferenceError: id is not defined" (por ejemplo en fetchNote)
# Esto convierte `{id}` -> `id` para que sea texto literal.
# ---------------------------------------------------------------------
echo "Sanitizing generated MDX/MD to avoid '{id}' evaluation..."
if command -v perl >/dev/null 2>&1; then
  find "${DOCS_OUT_DIR}" -type f \( -name "*.md" -o -name "*.mdx" \) -print0 \
    | xargs -0 perl -0777 -i -pe 's/\{id\}/`id`/g'
else
  # Fallback por si perl no existe (raro en ubuntu-latest, pero por si acaso)
  while IFS= read -r -d '' f; do
    sed -i.bak 's/{id}/`id`/g' "$f" && rm -f "${f}.bak"
  done < <(find "${DOCS_OUT_DIR}" -type f \( -name "*.md" -o -name "*.mdx" \) -print0)
fi

echo "Sanitize done."
